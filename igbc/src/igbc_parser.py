import pandas as pd
import warnings
import numpy as np

# Used to filter out warning messages generated by modules or functions called in code.
warnings.filterwarnings("ignore")

def get_HVAC_Zone_report(name, name1):
    # Define the markers inside the function
    start_marker = "Floors / Spaces / Walls / Windows / Doors"
    end_marker = "Electric & Fuel Meters"
    
    # Define fixed headers
    fixed_headers = ["WINDOW", "GLASS-TYPE", "FRAME-WIDTH", "X", "Y", "HEIGHT", "WIDTH", "FRAME-CONDUCT"]
    
    # Open the .inp file for reading
    with open(name) as f:
        # Read each line of the file
        flist = f.readlines()
    
    # Initialize variables
    in_section = False
    current_values = {}
    data = []  # Initialize the list to collect rows of data

    # Process each line to find relevant sections
    for line in flist:
        line = line.strip()
        
        if start_marker in line:
            in_section = True
            continue
        elif end_marker in line:
            in_section = False
            continue
        
        if in_section:
            if '=' in line:
                section, value = line.split('=', 1)
                section = section.strip()
                value = value.strip()
                if section == "WINDOW":
                    if current_values:
                        # Add current values to data before starting a new section
                        data.append([current_values.get(header, '') for header in fixed_headers])
                    # Start a new section
                    current_values = {fixed_headers[0]: value}  # Set the WINDOW column
                else:
                    if section in fixed_headers:
                        current_values[section] = value
            elif line.endswith('..') and current_values:
                # Save the last section data
                data.append([current_values.get(header, '') for header in fixed_headers])
                current_values = {}
    
    # Convert collected data into a DataFrame
    df1 = pd.DataFrame(data, columns=fixed_headers)

    start_marker1 = "Glass Types"
    end_marker1 = "Window Layers"

    # Open the .inp file for reading again
    with open(name) as f:
        # Read each line of the file
        flist = f.readlines()
    
    in_section1 = False
    window_values1 = []
    # Process each line to find relevant sections
    for line in flist:
        line = line.strip()
        
        if start_marker1 in line:
            in_section1 = True
            continue
        elif end_marker1 in line:
            in_section1 = False
            continue
        
        if in_section1:
            if "= GLASS-TYPE" in line:
                value = line.split('= GLASS-TYPE')[0].strip()
                if value:
                    window_values1.append(value)

    # Create a DataFrame with only the GLASS-TYPE column
    vlt = None
    gl_type = pd.DataFrame(window_values1, columns=["GLASS-TYPE"])
    if gl_type.empty:
        vlt = "38%"
    else:
        vlt = "20%"

    # Initialize variables
    in_section = False
    window_values = []
    
    # Process each line to find relevant sections
    for line in flist:
        line = line.strip()
        
        if start_marker in line:
            in_section = True
            continue
        elif end_marker in line:
            in_section = False
            continue
        
        if in_section:
            if '= WINDOW' in line:
                # Get the value to the left of '= WINDOW'
                value = line.split('= WINDOW')[0].strip()
                if value:
                    window_values.append(value)
    
    # Create a DataFrame with only the WINDOW column
    df2 = pd.DataFrame(window_values, columns=["WINDOW"])

    df1.iloc[:, 0] = df2.iloc[:, 0]
    df1.drop(df1.columns[[1, 2, 3, 4, -1]], axis=1, inplace=True)
    # convert to numeric last 2 columns
    df1.iloc[:, -2] = pd.to_numeric(df1.iloc[:, -2])
    df1.iloc[:, -1] = pd.to_numeric(df1.iloc[:, -1])
    df1['Window Area (Sqft)'] = df1.iloc[:, -2] * df1.iloc[:, -1]

    df1['Type of Window'] = ['W' + str(i) for i in range(1, len(df1) + 1)]

    # Insert the new column at the second position (index 1)
    df1.insert(1, 'Type of Window', df1.pop('Type of Window'))

    ##########################################   READ SIM FILE NOW   ##########################################
    # Open the file named 'name' and read its contents
    with open(name1) as f:
        # Read all lines from the file and store them in a list named flist
        flist = f.readlines()

        # Initialize an empty list to store line numbers where 'LV-B' occurs
        lvb_count = [] 
        # Iterate through each line in flist along with its line number
        for num, line in enumerate(flist, 0):
            # If 'LV-B' is in the line, append its line number to lvb_count list
            if 'LV-B' in line:
                lvb_count.append(num)
            # If 'LV-C' is in the line, store its line number as numend
            if 'LV-C' in line:
                numend = num
        # Store the line number of the first occurrence of 'LV-B'
        numstart = lvb_count[0] 
        # Slice flist from the start of 'LV-B' to the line before 'LV-C' and store it in lvb_rpt
        lvb_rpt = flist[numstart:numend]
        
        lvb_str = []
        # Iterate through each line in lvb_rpt
        for line in lvb_rpt:
            # Check conditions and append lines containing relevant data to lvb_str list
            if (('NO-INFILT.' in line and 'INT' in line) or ('NO-INFILT.' in line and 'EXT' in line) or
                ('AIR-CHANGE' in line and 'INT' in line) or ('AIR-CHANGE' in line and 'EXT' in line)):
                lvb_str.append(line)       
        
        # result list to store filtered columns. after 10th column from last remaining values in 1 column.
        result = []  
        for line in lvb_str:
            lvb_list = []
            # Split the line by whitespace and store the result in splitter
            splitter = line.split()
            # Join the first part of the splitter except the last 10 elements and store it as space_name
            space_name = " ".join(splitter[:-10])
            # Add space_name as the first element of lvb_list
            lvb_list=splitter[-10:]
            lvb_list.insert(0,space_name)
            # Append lvb_list to result
            result.append(lvb_list)
            
        # strore list to dataframe
        lvb_df = pd.DataFrame(result) 
        # Allot lvb_df columns from sim file
        lvb_df.columns = ['SPACE', 'SPACE*FLOOR', 'SPACE_TYPE', 'AZIMUTH', 
                             'LIGHTS(WATT / SOFT)', 'PEOPLE', 'EQUIP(WATT / SOFT)', 'INFILTRATION_METHOD', 'ACH',
                             'Carpet Area(Sqft)', 'VOLUME(CUFT)']
        
        # convert below columns of lvb_df to numeric datatypes
        lvb_df['Carpet Area(Sqft)'] = pd.to_numeric(lvb_df['Carpet Area(Sqft)'])
        lvb_df = lvb_df.iloc[:, [0, -2]]

        lvb_df.columns = ['SPACE', 'Carpet Area(Sqft)']

        # In df1 add both columns of lvb_df as a new column in starting 2 columns of df1
        df1 = pd.concat([lvb_df, df1], axis=1)
        df1 = df1.drop(df1.columns[2], axis=1)
        # delete all rows of last column rows is null or blank or NAN
        # Replace empty strings with NaN (optional, if you want to handle blanks as NaN)
        df1.replace('', np.nan, inplace=True)

        # Drop rows with any NaN values
        df1 = df1.dropna()
        # Define the name of the new blank column
        blank_col_name1 = 'L(M)'
        blank_col_name2 = 'W(M)'
        blank_col_name3 = 'Openable'

        df1.insert(loc=df1.columns.get_loc('Carpet Area(Sqft)'), column=blank_col_name1, value=None)
        df1.insert(loc=df1.columns.get_loc('Carpet Area(Sqft)'), column=blank_col_name2, value=None)
        df1.insert(loc=df1.columns.get_loc('Window Area (Sqft)'), column=blank_col_name3, value=None)
        
        # Add new columns at the end
        df1.insert(loc=len(df1.columns), column='Openable Area', value=None)
        df1.insert(loc=len(df1.columns), column='Carpet Area - Required', value=None)
        df1.insert(loc=len(df1.columns), column='Carpet Area - Achieved', value=None)
        # 50% value of column name- Window Area (Sqft)
        df1['Window Area (Sqft)'] = pd.to_numeric(df1['Window Area (Sqft)'], errors='coerce')
        # 50% of Area to thic column - '% of Openable Area to Carpet Area - Achieved'
        df1['Carpet Area - Achieved'] = df1['Window Area (Sqft)']/2

        ################## Create new dataframe say igbc_vlt which  takes 1st, 5th and 9th column of df1 ####################
        igbc_vlt = df1.iloc[:, [0, 3, 8]]

        # Add new columns at the end of igbc_vlt column name as- Window Glazing VLT (%) all value equal to vlt 
        igbc_vlt.insert(loc=len(igbc_vlt.columns), column='Window Glazing VLT (%)', value=vlt)
        # why value is None above- which is multiplation of Window Glazing VLT (%), Window Area (Sqft) and mulitpy with 0.2
        # and then assign value to it.
        # Remove the '%' symbol and convert the column to numeric
        igbc_vlt['Window Glazing VLT (%)'] = igbc_vlt['Window Glazing VLT (%)'].str.replace('%', '').astype(float)
        igbc_vlt['Window Glazing VLT (%)'] = pd.to_numeric(igbc_vlt['Window Glazing VLT (%)'])
        igbc_vlt['Window Area (Sqft)'] = pd.to_numeric(igbc_vlt['Window Area (Sqft)'])
        igbc_vlt['Carpet Area(Sqft)'] = pd.to_numeric(igbc_vlt['Carpet Area(Sqft)'])
        igbc_vlt['Glazing Factor Achieved'] = (igbc_vlt['Window Glazing VLT (%)'] * igbc_vlt['Window Area (Sqft)'] * 0.2)/igbc_vlt['Carpet Area(Sqft)']

        #create a new column name- "Regularly Occupied Spaces Meet or Exceed the Criteria (Yes/No)" if Glazing Factor Achieved > 1 then YES else NO
        igbc_vlt['Regularly Equipment (Yes/No)'] = None
        igbc_vlt['Regularly Equipment (Yes/No)'] = np.where(igbc_vlt['Glazing Factor Achieved'] > 1, 'YES', 'NO')
        igbc_vlt['Min. Glazing Area'] = igbc_vlt['Carpet Area(Sqft)'] /(igbc_vlt['Window Glazing VLT (%)'] * 0.2)
        igbc_vlt['Min. VLT'] = igbc_vlt['Carpet Area(Sqft)'] /(igbc_vlt['Window Area (Sqft)'] * 0.2)

    return df1, igbc_vlt

